
NOTE. To be updated per latest version of code. Some details 
may be outdated.

Passwordless Authentication for the Eager Words Application

General Web UI Design Considerations

There are a number of issues that complicate the design of a web front end
to an API. 

The standard mechanism for calling API functions in the backend server from
javascript is fetch. Fetch returns a promise that is resolved when it gets a
response from its asynchronous HTTP call to the server. So the effect of an API
call on the UI must be encoded in callbacks. 

An API call to the server may fail, and that failure may be manifested in a
number of different ways. First, through HTTP status, for example, 400 bad
request. Second through a rejection of the promise for some other reason. And
third through a normal response that indicates some sort of user error. These
errors must then ba categorized to user errors, recoverable system errors, and
unrecoverable system errors, each being processed by a different fork in the
code base.

Note that fetch by itself does not provide a timeout option for the amount of
time to wait for the resolution of the asynchronous call to the server. 
Timeout has to be added explicitly in wrapper to fetch. A timeout is often a
recoverable system error. But the recovery code can get complicated. To keep
things simple we consider timeouts as unrecoverable system errors.

In a passwordless system, logins have expiration times. For security reasons,
expiration times are only available in the server. Hence, when the user
requests a protected action, the UI does not know whether the user's login has
expired. To know that, a time-consuming asynchronous call has to be made to the
server. And until that call is resolved, the user needs feedback that an action
is in progress.

On another level, a user may enter a page of the application end under program
control, e.g., clicking a link or a button in the application, or the user may
enter a page of the application directly by entering its URL in the browser's
address bar. 

On entry through program control, the user is already in the context of an
application page and is trying to go to another page. That means we can control
access to the destination page while still in the calling page. If access is
not permitted, the user can stay on the source page and get an alert about why
access is not permitted in the context of that page. 

But when entering a page by using the address bar from some other random
location, the check cannot be done in the context of that random page. Which
application page should be provided as the context for telling the user that he
is not permitted to access the given URL? The simplest answer is to use the
destination page itself.

These considerations necessitate a consistent set of guidelines for dealing with
access-control, asynchronicity, and error processing throughout the application.

In the eagerwords application, we use the following guidelines.

Each page has a normal mode in which the user gets access to the data and
functions the page was designed for.

Each page has an unrecoverable error mode which is rendered when an
unrecoverable error is encountered. In this mode, all procesing is disabled, a
message is diplayed, and an OK button is provided that logs the user out, and
returns him to the default landing page.

Each page has an error message text area. When a user error or a recoverable
system error occurs, the page is not disturbed, but a message describing the
error and possible recovery options appears in the text area.

Each protected page has an "initialization in progress" mode that is shown 
while asynchronous calls needed to determine authentication status or to get 
the data needed to populate the page are in progress.

Each protected page has a login expired mode that is rendered if the user's
login has expired. This mi=ode is silimar to the unrecoverable error mode.

When a protected page is waiting on a server call for authentication or for its
data, the in-progess mode's content is rendered. When the callback from the
corresponding fetch is invoked, normal content or expired content is rendered
depending on whether the user is logged in or not. 

A user can enter a page and do nothing for a long time. The next interaction
with the server would then fail authentication, causing the application to reset
to the landing page. The user will only know this state of affairs when next
time he tries to interact with the server. This is not ideal - but will have to
do, for simplicity, in this version

Concepts

identifying email - the user's email - uniquely identifies the user once
validated

resource ownership - each server-side resource in uniquely owned by a given
email address

token - a unique random identifier generated by the server and sent to the
purported email of the user attempting to login - it validates that the user is
the owner of the given email address - and is therefore authorized to access the
resources owned by that email address

clientId - a random identifier generated by the server upon user login (or
sign-up) and returned to the client browser - it uniquely identifies the client
among all clients currently interacting with the server

Database Tables

- emailuser(id, email, nickname)

The id in an internal server-side unique identifier for the user. It is used as
a foreign key of owned resources. 

The email will be encrypted for extra security. The encryption key would be a
secret guarded by Vault or similar secure store. 

The user record is created upon user sign-up and checked when logging in.

- signup(id, email, nickname, clientId, token, expiration)

Indicates that the user is in the process of signing up.

User sign-up is a two-step process: In the first step a token is generated
and sent to the user's email to confirm the user owns the email, and 
a signup record is created as above. 

In the second step, the user having gotten the confirmation email uses 
the token to confirm his ownership of the email account by calling the API's
signup confirmation function, and providing both the clientId, and the 
authentication token.

Sign-up confimation must happen within a reasonable time interval of 
the corresponding sign-up initiation. The expiration field of the signup
record is the epoch second at which time the ability to complete signup 
expired.

- login(id, email, clientId, token, confirmed, expiration, confirmExpiration)

Used to keep track of the logged-in state of the email user.

For extra security, there can only be a single login at a time for a given email.

Also, of course, there can only be a single login for a given clientId.

The client is identified by clientId - the proof of email ownership is the token
sent to the user.

The login process is a two-step process involving the transmission of a token 
to the user's email address, similar to the two-step sign-up process. The 
confirmExpiration fields provides the time threshold up to which a login
initiation may be confirmed by providing the token. The expiration field
is the time at which the user's login expires.

Short expirations are more secure. Long expirations are more convenient for the
user. Default is in days. 

Additional Notes

The emailuser's id is used to enable access to the user's resources whose database
representation will include the owning userId. 

Note. Using the token only as a means of validating the user is insecure because
emails may be spoofed. With the addition of the clientId, a hacker would 
have infiltrate the user's browser. This passwordless scheme does 
not address vulnerabilities related to a compromised browser. Nor a compromised
control of the user's email. A hacker who is able to control the user's email,
can, of course, login as that user.

The Eula will make clear the security measures taken, and the known security
vulnerabilities.

When login expires the active game of the user if any is suspended in the
server.
  
So that the user is not abruptly stopped in playing a game when his login
expires, he is asked to login again if the game is started too close to the
login expiration time.

Default expiration might be 2 days. The threshold for starting a new game
might be 2 hours before expiration.

Of course, the server would only accept https requests.

To provide an enhanced user experience in cases where the user has not yet been
authenticated, we can first call the synchronous loggedOut function and take
care of that case with no delays or spinners, and only call checkLogin if we
still have a clientId and a token in local memory.

A user may abandon his browser session while still logged in. When the user 
tries to use the application again, hiw browser session will no longer contain
the authentication evidence for his login (the clientId, and the token). But as
far as the server is concerned, the user is still considered logged in. 

In order to interact with the protected parts of the application the user 
needs the client id and the token. But from the point of view of the server they 
are secrets. The only choice is to allow the user to log in again. In doing so,
the earlier login is cancelled and a new login sequence is started for the user.

